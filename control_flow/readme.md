# Estruturas de Controle e Cole√ß√µesüáßüá∑

### Objetivo

Trazer elementos das estruturas de repeti√ß√£o e condicionais, al√©m de conhecer algumas das principais cole√ß√µes do Kotlin.

#### Estruturas de Controle

* When
* Loops
* Ranges
* Verifica√ß√£o de igualdade
* Express√µes condicionais

#### Cole√ß√µesüáßüá∑

*  List
*  Set
*  Map
*  Extension Functions(filter, map, flatMap etc)

---

### When

Em vez da instru√ß√£o switch amplamente usada, o Kotlin fornece uma forma mais flex√≠vel e clara durante a constru√ß√£o. Pode ser usado como uma declara√ß√£o ou como uma express√£o. 

##### Declara√ß√£o `when`: 

```kotlin
fun main() {
    cases("Hello")
    cases(1)
    cases(0L)
    cases(MyClass())
    cases("hello")
}
‚Äã
fun cases(obj: Any) {                                
    when (obj) {                                     // 1   
        1 -> println("One")                          // 2
        "Hello" -> println("Greeting")               // 3
        is Long -> println("Long")                   // 4
        !is String -> println("Not a string")        // 5
        else -> println("Unknown")                   // 6
    }   
}

class MyClass
```

1. Esta √© uma declara√ß√£o `when`.
2. Verifica se obj √© igual a 1.
3. Verifica se obj √© igual a "Hello".
4. Executa verifica√ß√£o de tipo.
5. Executa verifica√ß√£o de tipo inversa.
6. Instru√ß√£o padr√£o (pode ser omitida).

Observe que todas as condi√ß√µes de ramifica√ß√£o s√£o verificadas sequencialmente at√© que uma delas seja satisfeita. Assim, apenas a primeira ramifica√ß√£o adequada ser√° executada. 

#### Express√£o `when`:

```kotlin
fun main() {
    println(whenAssign("Hello"))
    println(whenAssign(3.4))
    println(whenAssign(1))
    println(whenAssign(MyClass()))
}
‚Äã
fun whenAssign(obj: Any): Any {
    val result = when (obj) {                   // 1
        1 -> "one"                              // 2
        "Hello" -> 1                            // 3
        is Long -> false                        // 4
        else -> 42                              // 5
    }
    return result
}
```

1. Esta √© uma express√£o quando.
2. Define o valor como "um" se obj for igual a 1.
3. Define o valor como um se obj for igual a "Hello".
4. Define o valor como falso se obj for uma inst√¢ncia de Long.
5. Define o valor 42 se nenhuma das condi√ß√µes anteriores for satisfeita. Ao contr√°rio da instru√ß√£o in when, a ramifica√ß√£o padr√£o geralmente √© necess√°ria na express√£o when, exceto no caso em que o compilador pode verificar se outras ramifica√ß√µes cobrem todos os casos poss√≠veis.

---

### Loops

Kotlin suporta as principais formas de loops: `for`, `while`, `do-while`. 

#### for

`for` em Kotlin funciona como na maioria das linguagens.

```kotlin
val cakes = listOf("carrot", "cheese", "chocolate")
‚Äã
for (cake in cakes) {                               // 1
    println("Yummy, it's a $cake cake!")
}
```

1. Iterando sobre `cakes` para cada bolo na lista.

#### while and do-while

As constru√ß√µes while e do-while tamb√©m funcionam de maneira semelhante √† maioria das linguagens.

```kotlin
fun eatACake() = println("Eat a Cake")
fun bakeACake() = println("Bake a Cake")
‚Äã
fun main() {
    var cakesEaten = 0
    var cakesBaked = 0
    
    while (cakesEaten < 5) {                    // 1
        eatACake()
        cakesEaten ++
    }
    
    do {                                        // 2
        bakeACake()
        cakesBaked++
    } while (cakesBaked < cakesEaten)
‚Äã
}
```

1. Executa o bloco enquanto a condi√ß√£o for verdadeira.
2. Executa primeiro o bloco e depois verifica a condi√ß√£o.

#### Iterators

Voc√™ pode definir seus pr√≥prios iteradores em suas classes implementando o operador iterador nelas.

```kotlin
class Animal(val name: String)
‚Äã
class Zoo(val animals: List<Animal>) {
‚Äã
    operator fun iterator(): Iterator<Animal> {             // 1
        return animals.iterator()                           // 2
    }
}
‚Äã
fun main() {
‚Äã
    val zoo = Zoo(listOf(Animal("zebra"), Animal("lion")))
‚Äã
    for (animal in zoo) {                                   // 3
        println("Watch out, it's a ${animal.name}")
    }
‚Äã
}
```

1. Define um iterador em uma classe. Deve ser nomeado iterador e ter o modificador de operador.
2. Retorna o iterador que atende aos seguintes requisitos do m√©todo:
* next(): Animal
* hasNext(): Booleano
3. Percorre os animals do zoo com o iterador definido pelo usu√°rio.

O iterador pode ser declarado no tipo ou como uma fun√ß√£o de extens√£o.

---

### Ranges

Existe um conjunto de ferramentas para definir intervalos em Kotlin. Vamos dar uma breve olhada neles.

```kotlin
for(i in 0..3) {             // 1
    print(i)
}
print(" ")
‚Äã
for(i in 0 until 3) {        // 2
    print(i)
}
print(" ")
‚Äã
for(i in 2..8 step 2) {      // 3
    print(i)
}
print(" ")
‚Äã
for (i in 3 downTo 0) {      // 4
    print(i)
}
print(" ")
```

1. Itera em um intervalo que vai de 0 a 3 (inclusive). Como 'for(i=0; i<=3; ++i)' em outras linguagens de programa√ß√£o (C/C++/Java).
2. Itera em um intervalo de 0 a 3 (exclusivo). Como for loop em Python ou como 'for(i=0; i<3; ++i)' em outras linguagens de programa√ß√£o (C/C++/Java).
3. Itera em um intervalo com uma etapa de incremento personalizada para elementos consecutivos.
4. Itera em um intervalo na ordem inversa.

Os intervalos de caracteres tamb√©m s√£o suportados:

```kotlin
for (c in 'a'..'d') {              // 1
    print(c)
}

print(" ")
‚Äã
for (c in 'z' downTo 's' step 2) { // 2
    print(c)
}

print(" ")
```

1. Itera em um intervalo de caracteres em ordem alfab√©tica.
2. Os intervalos de caracteres tamb√©m suportam step e downTo.

Os intervalos tamb√©m s√£o √∫teis em instru√ß√µes if:

```kotlin
val x = 2
if (x in 1..5) {             // 1
    print("x is in range from 1 to 5")
}
println()
‚Äã
if (x !in 6..10) {          // 2
    print("x is not in range from 6 to 10")
}
```

1. Verifica se um valor est√° no intervalo.
2. `!in` √© o oposto de `in`.

---

### Equality Checks

Kotlin usa `==` para compara√ß√£o estrutural e `===` para compara√ß√£o referencial.
Mais precisamente, `a == b` compila para `if (a == null) b == null else a.equals(b)`.
‚Äã
```kotlin
val authors = setOf("Shakespeare", "Hemingway", "Twain")
val writers = setOf("Twain", "Shakespeare", "Hemingway")
‚Äã
println(authors == writers)   // 1
println(authors === writers)  // 2
```

1. Retorna verdadeiro porque chama authors.equals(writers) e define para ignorar a ordem dos elementos.
2. Retorna falso porque authors e writers s√£o refer√™ncias distintas.

---

### Conditional Expression

N√£o h√° operador tern√°rio `condi√ß√£o? ent√£o: else` em Kotlin. Em vez disso, `if` pode ser usado como uma express√£o:

```kotlin
fun max(a: Int, b: Int) = if (a > b) a else b         // 1
‚Äã
println(max(99, -42))
```

1. `if` √© uma express√£o aqui: retorna um valor.

---

# Control Flowüá∫üá∏

### Goal

Bring elements of repetition and conditional structures, in addition to getting to know some of Kotlin's main collections.

#### Control flow

* When
* Loops
* Ranges
* Equality check
* Conditional expressions

#### Collections

*  List
*  Set
*  Map
*  Extension Functions(filter, map, flatMap etc)

---

### When

Instead of the widely used switch statement, Kotlin provides the more flexible and clear when construction. It can be used either as a statement or as an expression. 

#### When Statement: 

```kotlin
fun main() {
    cases("Hello")
    cases(1)
    cases(0L)
    cases(MyClass())
    cases("hello")
}
‚Äã
fun cases(obj: Any) {                                
    when (obj) {                                     // 1   
        1 -> println("One")                          // 2
        "Hello" -> println("Greeting")               // 3
        is Long -> println("Long")                   // 4
        !is String -> println("Not a string")        // 5
        else -> println("Unknown")                   // 6
    }   
}

class MyClass
```

1. This is a when statement.
2. Checks whether obj equals to 1.
3. Checks whether obj equals to "Hello".
4. Performs type checking.
5. Performs inverse type checking.
6. Default statement (might be omitted).

Note that all branch conditions are checked sequentially until one of them is satisfied. So, only the first suitable branch will be executed.

#### When Expression:

```kotlin
fun main() {
    println(whenAssign("Hello"))
    println(whenAssign(3.4))
    println(whenAssign(1))
    println(whenAssign(MyClass()))
}
‚Äã
fun whenAssign(obj: Any): Any {
    val result = when (obj) {                   // 1
        1 -> "one"                              // 2
        "Hello" -> 1                            // 3
        is Long -> false                        // 4
        else -> 42                              // 5
    }
    return result
}
```

1. This is a when expression.
2. Sets the value to "one" if obj equals to 1.
3. Sets the value to one if obj equals to "Hello".
4. Sets the value to false if obj is an instance of Long.
5. Sets the value 42 if none of the previous conditions are satisfied. Unlike in when statement, the default branch is usually required in when expression, except the case when the compiler can check that other branches cover all possible cases.

---

### Loops

Kotlin supports all the commonly used loops: `for`, `while`, `do-while`. 

#### for

`for` in Kotlin works the same way as in most languages.

```kotlin
val cakes = listOf("carrot", "cheese", "chocolate")
‚Äã
for (cake in cakes) {                               // 1
    println("Yummy, it's a $cake cake!")
}
```

1. Loops through each cake in the list.

#### while and do-while

while and do-while constructs work similarly to most languages as well.

```kotlin
fun eatACake() = println("Eat a Cake")
fun bakeACake() = println("Bake a Cake")
‚Äã
fun main() {
    var cakesEaten = 0
    var cakesBaked = 0
    
    while (cakesEaten < 5) {                    // 1
        eatACake()
        cakesEaten ++
    }
    
    do {                                        // 2
        bakeACake()
        cakesBaked++
    } while (cakesBaked < cakesEaten)
‚Äã
}
```

1. Executes the block while the condition is true.
2. Executes the block first and then checking the condition.

#### Iterators

You can define your own iterators in your classes by implementing the iterator operator in them.

```kotlin
class Animal(val name: String)
‚Äã
class Zoo(val animals: List<Animal>) {
‚Äã
    operator fun iterator(): Iterator<Animal> {             // 1
        return animals.iterator()                           // 2
    }
}
‚Äã
fun main() {
‚Äã
    val zoo = Zoo(listOf(Animal("zebra"), Animal("lion")))
‚Äã
    for (animal in zoo) {                                   // 3
        println("Watch out, it's a ${animal.name}")
    }
‚Äã
}
```

1. Defines an iterator in a class. It must be named iterator and have the operator modifier.
2. Returns the iterator that meets the following method requirements:
* next(): Animal
* hasNext(): Boolean
3. Loops through animals in the zoo with the user-defined iterator.

The iterator can be declared in the type or as an extension function.

---

### Ranges

There is a set of tools for defining ranges in Kotlin. Let's have a brief look at them.

```kotlin
for(i in 0..3) {             // 1
    print(i)
}
print(" ")
‚Äã
for(i in 0 until 3) {        // 2
    print(i)
}
print(" ")
‚Äã
for(i in 2..8 step 2) {      // 3
    print(i)
}
print(" ")
‚Äã
for (i in 3 downTo 0) {      // 4
    print(i)
}
print(" ")
```

1. Iterates over a range starting from 0 up to 3 (inclusive). Like 'for(i=0; i<=3; ++i)' in other programming languages (C/C++/Java).
2. Iterates over a range starting from 0 up to 3 (exclusive). Like for loop in Python or like 'for(i=0; i<3; ++i)' in other programming languages (C/C++/Java).
3. Iterates over a range with a custom increment step for consecutive elements.
4. Iterates over a range in reverse order.

Char ranges are also supported:

```kotlin
for (c in 'a'..'d') {              // 1
    print(c)
}

print(" ")
‚Äã
for (c in 'z' downTo 's' step 2) { // 2
    print(c)
}

print(" ")
```

1. Iterates over a char range in alphabetical order.
2. Char ranges support step and downTo as well.
Ranges are also useful in if statements:

```kotlin
val x = 2
if (x in 1..5) {             // 1
    print("x is in range from 1 to 5")
}
println()
‚Äã
if (x !in 6..10) {          // 2
    print("x is not in range from 6 to 10")
}
```

1. Checks if a value is in the range.
2. `!in` is the opposite of `in`.

---

### Equality Checks

Kotlin uses `==` for structural comparison and `===` for referential comparison.
More precisely, `a == b` compiles down to `if (a == null) b == null else a.equals(b)`.
‚Äã
```kotlin
val authors = setOf("Shakespeare", "Hemingway", "Twain")
val writers = setOf("Twain", "Shakespeare", "Hemingway")
‚Äã
println(authors == writers)   // 1
println(authors === writers)  // 2
```

1. Returns true because it calls authors.equals(writers) and sets ignore element order.
2. Returns false because authors and writers are distinct references.

---

### Conditional Expression

There is no ternary operator `condition ? then : else` in Kotlin. Instead, `if` may be used as an expression:

```kotlin
fun max(a: Int, b: Int) = if (a > b) a else b         // 1
‚Äã
println(max(99, -42))
```

1. if is an expression here: it returns a value.